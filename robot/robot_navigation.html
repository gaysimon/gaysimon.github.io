<!DOCTYPE html>
<html >
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link rel="stylesheet" href="/style1.css" type="text/css" />
		<title>Plateforme omnidirectionnelle</title>
	</head>

	<body>
	
		<header>
			<div id="banniere_image"> </div>
		</header>
	
		<div class="main">
			<nav>
                	<a href="/index.html">Accueil</a><br />
			<a href="/recherches.html">Recherches</a><br />
			<a href="/postdoc.html">Mon PostDoc</a><br />
			<a href="/these.html">Ma These</a><br />
			<a href="/publi.html">Publications</a><br />
			<a href="/robot.html">Les Robots</a><br />
			<a href="/software.html">logiciels</a><br />
			<br />
			<a href="/robot/robot_navigation.html"><img src="/img/fr.png" alt="fr" /> </a>
			<a href="/robot/robot_navigation_en.html"><img src="/img/en.png" alt="en" /> </a>
			</nav>

			<section class="subsection">
				<p>
					<center style="text-align: center;font-size: xx-large;">Plateforme robotique omni-directionnelle</center><br />
					<br />
				</p>

				<figure style="text-align:center">
					<img src="/projects/robot.jpg" alt="robotic platform" width="600" />
					<figcaption>Une plateforme omni-directionnelle pour étudier des modèles de navigation autonome.</figcaption>
				</figure>
				
				<br/>
				<br/>
				<p>
					Ce robot a été conçu pour tester et valider nos <a href="https://gaysimon.github.io/postdoc/navig2.html">modèles de navigation bio-inspirés</a> en environnement réel. Le choix de la plateforme a été dictée par différentes contraintes : déplacements omni-directionnels pour simuler les déplacements d'une personne, abordable pour pouvoir s'équiper d'une flottille de robot, et d'une taille suffisante pour pouvoir être équipé d'un nano-ordinateur et d'une caméra binoculaire. Notre choix s'est porté sur la plateforme Mecanum Wheel produit par Osoyoo. Cette plateforme a ensuite été équipée d'un étage supplémentaire pour accueillir de nouveaux composants.
				</p>
			
			</section>
			
			
			<section class="subsection">
				<section class="listsection">

					<p>
						<center style="text-align: center;font-size: xx-large;">La plateforme Mecanum Wheel</center><br /><br />
					</p>

					<p>
						La plateforme <a href=https://osoyoo.com/2022/07/05/v2-metal-chassis-mecanum-wheel-robotic-for-arduino-mega2560-introduction-model-2021006600/>Mecanum Wheel de Osoyoo</a> constitue une base intéressante pour notre plateforme de test : elle est relativement simple à assembler et propose des déplacements omni-directionnel. Son architecture, reposant sur des composants répandus (Arduino et carte de contrôle moteur L293), facilite l'interface avec des composants additionnels.
					</p>


					<figure style="text-align:center">
						<img src="/robot/mecanuum_platform.jpg" alt="mecanum platform" width="400" />
						<figcaption>La plateforme Mecanum Wheel assemblée. L'Arduino est équipé d'un shield Wifi/Bluetooth. Le kit comprend également un sonar monté sur un servomoteur ainsi qu'un capteur de ligne au sol. </figcaption>
					</figure>

					<p>
						La plateforme est équipée de quatre roues dite "mecanum", c'est à dire dotées de petites roulettes internes. Contrairement aux roues omni-directionnelles (ou roues holonomes), dont les roulettes sont perpendiculaires à l'axe de la roue, les roues mecanum ont des roulettes inclinées de 45° par rapport à l'axe. Cette configuration particulière permet, avec un robot équipé de quatre de ces roues, de pouvoir se déplacer dans toutes les directions, avec une direction particulière (avant/arrière) ne générant pas de frottement supplémentaire à cause du roulement des roulettes internes, contrairement aux robots holonomes à trois roues, dont les roulettes génèrent un frottement supplémentaire quelle que soit la direction.
					</p>

					<figure style="text-align:center">
						<img src="/robot/Mecanum_wheel_control_principle.png" alt="mecanum wheels" width="600" />
						<figcaption>Déplacements d'un robot équipé de quatre roues mecanum. Lorsque deux roues du même côté tournent en sens inverse, le déplacement vers l'avant ou l'arrière s'annule, tandis que le roulement des roulettes provoque un déplacement sur le côté. En jouant sur la vitesse des quatre roues, le robot peut se déplacer dans toutes les directions (<a href="https://en.wikipedia.org/wiki/Mecanum_wheel">source</a>).</figcaption>
					</figure>

				</section>

				
				<section class="listsection">

					<p>	
						Démonstration des possibilités de déplacement de la plateforme, ici contrôlé avec une manette de jeux :
					</p>
			
					<p style="text-align: center">
 						<video width="400" controls >
  							<source src="/robot/robot_control.mp4" type="video/mp4">
							Your browser does not support the video tag.
						</video> 
					</p>

					<p>	
						Code source :<br>
						- Code Arduino : <a href="/robot/robot_control_bluetooth.ino">robot_control_bluetooth.ino</a> <br>
						- Interface Java : <br>
						&emsp; Contrôle avec souris : <a href="/robot/robot_control_mouse.zip">robot_control_mouse.zip</a> (nécessite la librairie <a href="https://github.com/java-native/jssc/releases">JSSC</a>) <br>
						&emsp; Contrôle avec manette : <a href="/robot/robot_control_gamepad.zip">robot_control_gamepad.zip</a> (nécessite les librairies <a href="https://github.com/java-native/jssc/releases">JSSC</a> et <a href="https://jar-download.com/artifacts/net.java.jinput/jinput/">jinput</a>) <br>
					</p>

					<p>
						Instructions :<br>
				
						- Connecter le robot avec votre PC, en suivant le <a href="https://osoyoo.com/2022/07/05/v2-metal-chasiss-mecanum-wheel-robotic-for-arduino-mega2560-lesson-4-bluetooth-imitation-driving/">tutoriel d'Osoyoo</a> <br>
						- Téléverser le code .ino dans l'Arduino du robot<br>
						- Créer un nouveau projet Java, et importer les fichiers d'une des deux archives<br>
						- A l'aide de l'IDE Arduino, déterminer sur quel port le dongle Bluetooth est connecté : le programme envoie le mot "test" en boucle, que vous pouvez lire avec le moniteur série. Sélectionner ensuite le port permettant de se connecter à l'Arduino par USB pour libérer le port Bluetooth<br>
						- Dans la classe Main, indiquer le port utilisé par le dongle Bluetooth (ligne 6)<br>
						- Lancer le programme java. Une fenêtre doit s'ouvrir<br>
						- Cliquer dans la fenêtre pour faire apparaître un joystick virtuel. Sans relâcher le bouton, de déplacer le curseur autour du point initial pour contrôler le robot : bouton gauche pour avant/arrière/translations et bouton droit pour avant/arrière/rotations. Le robot s'arrête quand on relâche le bouton.<br>

						<figure style="text-align:center">
							<img src="/robot/virtual_joystick.png" alt="Joystick virtuel" width="250" />
						</figure>

						Pour utiliser la manette :<br>
						- Déterminer le nom du périphérique dans la liste qui s'affiche dans le terminal

						<figure style="text-align:center">
							<img src="/robot/omni_gamepad1.png" alt="liste périphériques" width="600" />
						</figure>

						- Copier le nom du périphérique dans la classe Main, ligne 7
						<figure style="text-align:center">
							<img src="/robot/omni_gamepad2.png" alt="Nom de la manette" width="600" />
						</figure>

						- Relancer l'application Java
					</p>
				</section>

				
				<section class="listsection">
			
					<p>	
						Intégration d'une centrale inertielle (IMU) GY-87 :
				
						<figure style="text-align:center">
							<img src="/robot/IMU.jpg" alt="IMU GY-87" width="250" />
							<figcaption>Centrale inertielle GY-87.</figcaption>
						</figure>
					</p>
			
					<p>		
						La centrale inertielle GY-87 est une carte de développement munie d'un accéléromètre et gyroscope MPU6050 permettant de mesurer les accélérations et les rotations sur 3 axes, d'un magnétomètre HMC5883L pouvant servir de boussole, et d'un capteur de pression barométrique BMP180. La carte peut être alimenté en 5V ou en 3.3V. Ces capteurs permettent une estimation relativement précise des déplacements du robot dans son environnement.
					</p>
			
					<p>
						La connexion de la carte IMU à l'Arduino est très simple :<br>
						- l'alimentation est reliée aux broches 5V et Gnd de l'Arduino. <br>
						- les données sont transmises par les broches SCL et SDA, connectées aux broches correspondantes sur l'Arduino (broches 'SCL 21' et 'SDA 20' de l'Arduino Mega du robot).
			
						<figure style="text-align:center">
							<img src="/robot/IMU_connect.png" alt="connexion de la carte IMU" width="600" />
							<figcaption>Connexion de la carte GY-87 à l'Arduino Mega du robot.</figcaption>
						</figure>
					</p>
			
					<p>
						Vous trouverez de nombreux détails pour intégrer cette carte IMU sur le site d'<a href="https://github.com/OlivierGeorgeon/osoyoo/">Olivier Georgeon</a>.
					</p>
							
					<p>
						La carte est maintenue dans un support imprimé en 3D et placée à l'avant du robot. Vous trouverez ci-dessous le modèle du support et les codes Arduino et java permettant de lire les informations issues de la carte.
					</p>
					
					<p>	
						Code source :<br>
						- Modèle support : <a href="/robot/IMU.stl">IMU.stl</a> <br>
						- Code Arduino : <a href="/robot/robot_control_bluetooth_IMU.ino">robot_control_bluetooth_IMU.ino</a> <br>
						- Interface Java : <br>
						&emsp; Contrôle avec souris : <a href="/robot/robot_control_mouse_IMU.zip">robot_control_mouse_IMU.zip</a> (nécessite la librairie <a href="https://github.com/java-native/jssc/releases">JSSC</a>) <br>
						&emsp; Contrôle avec manette : <a href="/robot/robot_control_gamepad_IMU.zip">robot_control_gamepad_IMU.zip</a> (nécessite les librairies <a href="https://github.com/java-native/jssc/releases">JSSC</a> et <a href="https://jar-download.com/artifacts/net.java.jinput/jinput/">jinput</a>) <br>
					</p>
			
				</section>
			</section>

		
			<section class="subsection">
				<section class="listsection">
					
					<p>
						<center style="text-align: center;font-size: xx-large;">Une plateforme pour l'étude de modèles de navigation</center><br /><br />
					</p>

					<p>
						Afin de rendre le robot autonome, tout en permettant du traitement d'image et la localisation, la plateforme a été équipée d'un nano-ordinateur. Les célèbres Raspberry Pi 4 étant en rupture de stock en cette période, notre choix s'est porté sur un modèle équivalent : le <a href="https://wiki.banana-pi.org/Banana_Pi_BPI-M5">Banana Pi M5</a>. Celui-ci n'étant pas équipé d'une connexion Wifi, un dongle doit être ajouté. Nous avons utilisé un dongle basé sur un chipset Ralink RT5370-MT7601 (attention, le chipset RT5370-MTK7601 ne fonctionne pas avec la version de Raspbian utilisée). La caméra binoculaire est une caméra de Playstation 4 (PS4Eye) modifiée pour pouvoir être branchée sur un port USB3 (tutoriel disponible <a href="https://www.instructables.com/HACK-PlayStation-4-Cam-Into-Cheap-3D-Depth-Camera-/">ici</a>). L'ensemble est alimenté par une batterie de type powerbank de 20Ah, indépendante de la batterie des moteurs. Nous utilisons un cable USB avec interrupteur pour ne pas avoir à débrancher le câble pour couper l'alimentation. Le système communique avec la plateforme robotique par une connexion USB avec l'Arduino du robot.<br/>
					</p>
		
					<figure style="text-align:center">
						<img src="/robot/platform_components.jpg" alt="Composants additionnels" width="600" />
						<figcaption>Composants additionnels de la plateforme. De gauche à droite : l'ordinateur de bord Banana Pi M5 (équipé d'un dongle Wifi), La caméra binoculaire PS4 eye modifiée, et la batterie Powerbank.</figcaption>
					</figure>
					<br/>

					<p>
						Les composants additionnels sont placés sur une plaque de plexi de 5mm d'épaisseur maintenue au châssis par des entretoises, et tenu par des supports imprimés en 3D. Le boîtier du Banana Pi est basé sur <a href="https://www.thingiverse.com/thing:5147307">ce modèle</a>. Le support de la batterie est conçue pour une powerbank modèle Intenso XS20000, de dimensions 128 x 70 x 25,2 mm. Ce support maintien également le dongle Wifi, relié au Banana Pi par une rallonge USB de 10cm. Les supports de la caméra sont conçus pour la version 1 de la PS4 eye. Il faut en imprimer deux, dont un qui doit être inversé (supports symétriques).<br />
						- Support batterie : <a href="/robot/batterie_support.stl">batterie_support.stl</a><br />
						- Support caméra : <a href="/robot/camera_support.stl">camera_support.stl</a><br />
					</p>
					<br />

					<figure style="text-align:center">
						<img src="/robot/architecture_robot.svg" alt="Architecture de la plateforme" width="500" />
						<figcaption>Architecture de la plateforme : à gauche, l'ordinateur de bord, équipé d'une caméra binoculaire et d'un dongle Wifi, et alimenté par une powerbank. Il communique par USB avec l'Arduino de la plateforme, qui pilote les moteurs via des cartes de contrôle. Les moteurs sont alimentés par leur propre batterie.</figcaption>
					</figure>
					<br />

					<figure style="text-align:center">
						<a href="/robot/platform_details.jpg"><img src="/robot/platform_details.jpg" style="border: 2px blue solid" alt="détails composants additionnels" width="500" /></a>
						<figcaption>Détails de la plaque supérieure supportant les composants additionnels.</figcaption>
					</figure>
					<br />

					<p>	
						D'un point de vue logiciel, le Banana Pi du robot tourne sous une version de Raspbian adaptée à cette carte (version 2023-05-03, avec un noyau 5.17.2-meson64) disponible sur ce <a href="https://wiki.banana-pi.org/Banana_Pi_BPI-M5#Raspbian">wiki</a>. Il est conseillé d'installer les logiciels suivants :<br/>
						- openssh-server : pour se connecter en ssh depuis un autre poste,<br/>
						- xrdp : pour se connecter à distance sur une session graphique (e.g. Remmina),<br/>
						- OpenJDK : pour utiliser le code fourni sur cette page. Le robot utilise la version 17,<br/>
						- Eclipse : une IDE pour développer en Java directement sur le robot,<br/>
						- Python3 : pour utiliser le programme qui transfère le firmware dans la caméra,<br/>
						- guvcview : pour tester la caméra,<br/>
						- libjssc-java : une librairie Java pour utilsier le port série.<br/>
					</p>
					
					<p>
						La communication s'effectue par le port série USB. Voici le code source pour l'Arduino et une classe Java servant d'interface :<br />
						- code arduino : <a href="/robot/robot_control_usb.ino">robot_control_usb.ino</a> <br>
						- interface Java : <a href="/robot/Robot.java">Robot.java</a> (nécessite la librairie <a href="https://github.com/java-native/jssc/releases">JSSC</a>, sur le robot, il faudra utiliser le .jar disponible dans /usr/share/java/ après avoir installé libjssc-java) <br>
					</p>

					<p>
						Il faut ensuite installer OpenCV pour Java. Vous pouvez suivre ce <a href="https://qengineering.eu/install-opencv-4.4-on-raspberry-pi-4.html">tutoriel</a>. Il faut toutefois s'assurer, après la commande <code>CMake</code>, que le compilateur a bien trouvé les exécutables ANT et JNI. Il faut également sauter la commande <code>make clean</code> pour ne pas supprimer le fichier .jar généré. Si tout s'est bien déroulé, après une longue compilation, le fichier .jar doit être présent dans le dossier /home/pi/opencv/build/bin, et les librairies .so dans le dossier /home/pi/opencv/build/lib.
					</p>
					
				</section>


				<section class="listsection">

					<p>
						Utilisation de la caméra PS4Eye :
					</p>

					<p>
						La PS4Eye necessite de transférer un firmware avant utilisation. Il faut dans un premier temps débrancher puis rebrancher la caméra. Il est possible de tester si la caméra est reconnue avec un <code>lsusb</code> dont le résultat doit faire apparaître la caméra :<br/>
						<br/>
					
						<code>&emsp;ID 05a9:0580 OmniVision Technologies</code> <br/>
						<br/>
					
						Dans le cas contraire, il faut vérifier les connexions.<br/><br/>
						On transfère ensuite le firmware à l'aide du code fourni <a href="https://github.com/sieuwe1/PS4-eye-camera-for-linux-with-python-and-OpenCV">ici</a> :<br/><br/>
					
						<code>
						&emsp;cd Firmware_loader<br/>
						&emsp;sudo python3 ps4eye_init.py<br/>
						</code><br/>
				
						Si tout se passe bien, le message suivant doit s'afficher :<br/><br/>
					
						<code>&emsp;PS4 camera firmware uploaded and device reset</code><br/><br/>
					
						La caméra peut ensuite être utilisée comme une simple webcam (ici, avec guvcview) :
					
						<figure style="text-align:center">
							<img src="/robot/camera_view1.jpg" alt="vue de la caméra" width="600" />
							<figcaption>Image issue de la caméra : la caméra fournit des images de 3748x808 pixels, comprenant les images des deux caméras et des versions compressées de ces images.</figcaption>
						</figure>
						<br/>
					
						Les images fournies par la caméra ont une taille de 3748x808 pixels, et comprennent les images issues des deux caméras, de taille 1280x800 pixels chacunes, ainsi que des versions réduites de ces images. Le code suivant permet d'obtenir deux images à partir du flux de la caméra :<br/>
					
						- <a href="/robot/camera.zip">camera.zip</a>
						<br/>
						<br/>
					
						Pour utiliser ce code, créez un nouveau projet (par exemple dans Eclipse), et importez les fichiers de l'archive ci-dessus. Associez la librairie opencv.jar (Build path->Configure build path->Libraries->add external JAR) obtenue après la compilation, puis spécifiez l'emplacement des librairies natives :<br/>
					
						<figure style="text-align:center">
							<img src="/robot/dependancies_opencv.png" alt="librairies OpenCV" width="300" />
						</figure>
						<br/>
					
						Dans la classe Main, il est possible de spécifier le numéro de la caméra, le framerate (si l'image est trop sombre, baisser à 30fps pour augmenter le temps d'exposition), et activer le réglage automatique de la luminosité (uniquement sous Linux).<br/>
						L'exécution du programme ouvre une fenêtre affichant les deux images gauche et droite séparées :
					
						<figure style="text-align:center">
							<img src="/robot/camera_view2.png" alt="deux images issues de la caméra" width="600" />
							<figcaption>Images gauche et droite séparées.</figcaption>
						</figure>
				
						A noter : ce programme fonctionne aussi sur un PC Linux ou Windows.
					</p>
							
				</section>

				<section class="listsection">
				
					<p>
						Un système de vision stéréoscopique simplifié :
					</p>
					
					<p>
						Les algorithmes de correspondance stéréoscopiques consistent à comparer deux images stéréoscopiques d'une scène, puis de déterminer la position de chaque pixel de la première image dans la seconde. La différence de position, ou disparité, permet de calculer la distance de ce point. Les algorithmes de concordance stéréoscopiques permettent ainsi d'obtenir la carte de profondeur de la scène. 
					</p>
				
					<figure style="text-align:center">
						<img src="/robot/cones_disparity.jpg" alt="concordance stéréoscopique entre deux images" width="600" />
						<figcaption>Algorithme de concordance stéréoscopique : on utilise deux images prises à deux positions différentes (ici, les images 'cônes' du <a href="https://vision.middlebury.edu/stereo/data/">dataset Middlebury</a> de 2003). En estimant la disparité de chaque pixel, on obtient la carte de profondeur de la scène (à droite).</figcaption>
					</figure>
					
					<p>
						Cependant, les algorithmes de concordance stéréoscopiques sont particulièrement lourd, surtout pour un nano-ordinateur. Comme nous visons une navigation à deux dimensions, la carte de disparité n'est pas nécessaire : seule la position de points d'intérêts dans le plan est nécessaire. Nous avons choisi d'utiliser les lignes verticales visibles dans la scène : elles sont en effet facilement identifiables, omniprésentes dans l'environnement, et localisable à l'aide d'images stéréoscopiques. Dans une carte 'vue du dessus', ces lignes verticales deviennent des points d'intérêt exploitables pour se localiser.<br/>
					</p>
					
					<p>
						L'algorithme utilise les étapes suivantes :<br/>
						- détection de contours verticaux,<br/>
						- détection des principales lignes verticales, par accumulation des contours d'une même colonne de pixels,<br/>
						- filtrage des lignes pour ne garder que les plus marquées,<br/>
						- récupérations des points de contours situés sur ces lignes,<br/>
						- utilisation d'un algorithme de flux optique sur ces points, utilisés entre les deux images,<br/>
						- calcul de la position des points à partir de la disparité,<br/>
						- récupération de la distance médiane de chaque ligne verticale,<br/>
						- projections des lignes sur la carte de navigation.<br/>
					</p>
					
					<p>
						On notera l'utilisation d'un algorithme de flux optique (ici, la fonction <code>calcOpticalFlowPyrLK</code> d'OpenCV), détourné de son utilisation usuelle : plutôt que de déterminer le mouvement de points entre deux images consécutives, on détermine la disparité de ces points entre les images gauche et droite. D'autre part, on sépare les points selon le sens du gradient du contours, permettant d'obtenir deux types de points d'intérêt.
					</p>
					
					<figure style="text-align:center">
						<img src="/projects/stereo_vision.png" alt="Les étapes du traitement des images stéréoscopiques" width="350" />
						<figcaption>Etapes du traitement : à gauche : des contours verticaux sont détectés dans une image. Les contours sont accumulés par colonne (histogramme en bas), permettant de récupérer les lignes les plus marquées. La couleur de la ligne indique le gradient (foncé vers clair ou clairs vers foncé). A droite, on applique un algorithme de flux optique sur les points de contours de ces lignes pour obtenir leur disparité, et donc la distance de ces lignes. En bas, ces lignes sont projetés sur une carte en 'vue du dessus'.</figcaption>
					</figure>
					
					<p>
						Cet algorithme nous a permis de tester notre système de navigation bio-inspiré en <a href="https://gaysimon.github.io/projects/navig_camera_en.html">environnement réel</a>, dans un premier temps avec un PC portable, puis sur la plateforme robotique.
					</p>
					
					<p>
						Le code suivant permet d'obtenir la carte de navigation à partir de l'image issue d'une PS4Eye. Il fonctionne à environ 40-50 images/s sur un PC avec un CPU  i5-10210U, et à environ 8-12 images/s sur le Banana Pi M5.<br/>
						- <a href="/robot/stereo.zip">stereo.zip</a>
					</p>
					
					<p>
						Comme précédemment, il faudra associer les librairies OpenCV à votre projet, et éventuellement modifier les paramètres dans la classe Main. Pour plus d'efficacité, il faudra également changer la hauteur maximale et minimale (en cm) des points considérés en fonction de la hauteur de la camera, dans la classe StereoVision, ligne 277.
					</p>
					
					<figure style="text-align:center">
						<img src="/robot/stereo_camera.png" alt="Obtention de la carte de navigation" width="600" />
						<figcaption>A gauche : l'image de gauche issue de la caméra, avec les lignes verticales détectées. A droite : la carte de navigation avec les points d'intérêt localisés dans l'espace.</figcaption>
					</figure>
				
				</section>

				<section class="listsection">
					
					<p>
						Un contrôle par interface web:
					</p>
					
					<p>
						Afin d'effectuer des tests sur le robot sans forcément utiliser une session graphique à distance, nous avons développé une interface web reposant sur un serveur web minimaliste. Ce serveur propose une unique page web comportant des fonctions pour interpréter les informations issues du robot et dessiner le contenu des afficheurs dans le navigateur. Le serveur se connecte également au client à l'aide d'un websocket Java autorisant l'échange d'informations entre le client et le serveur.
					</p>
					
					<p>
						Ce serveur est constitué de trois éléments :<br/>
						- Server.java : il s'agit du serveur Web à propement parler. Il reçois les requêtes du client et retourne la page HTML. C'est également lui qui initialise les deux modules suivants,<br/>
						- DataWebSocket.java : une classe initialisant un websocket entre le client et le serveur. La fonction <code>onMessage</code> permet de traiter les messages issus du client. La fonction broadcast permet d'envoyer un message (sous forme de chaine de catactères) au client,<br/>
						- VideoSocket.java : un socket dédié à l'envoi d'un flux vidéo. Ce module fonctionne sur un thread séparé, et envoie l'image de la caméra gauche toute les 100ms.
					</p>
						
					<p>
						Pour la communication avec le client, le protocole consiste en un mot-clé suivi d'éventuels arguments séparés par des espaces :<br/>
						<br/>
						
						Côté serveur, le traitement des messages a lieu dans la fonction onMessage de la classe DataWebSocket,<br/>
						- 'robot' permet d'envoyer des commandes de direction au robot (par exemple 'robot forward'),<br/>
						- 'system' permet de contrôler l'application. La commande 'system stop' permet d'arrêter l'application,<br/>
						- 'message' permet d'afficher un message sur la console.<br/>
						<br/>
						
						Côté client, le traitement a lieu dans une fonction JavaScript associée à un eventListener.<br/>
						- 'framerate' permet d'afficher le nombre d'images/s actuel,<br/>
						- 'context' fourni le contenu du contexte de points sous forme de triplet 'type posx distance'.<br/>
					</p>
					
					<p>
						L'interface avec l'Arduino du robot est similaire à celle utilisée pour le contrôle avec une manette, avec envoi de messages pour contrôler les moteurs, et un Listener pour récupérer les informations de déplacement, si une IMU est connectée à l'Arduino.
					</p>
					
					<p>
						Code source : <br/>
						- <a href="/robot/robot_control_usb.ino">robot_control_usb.ino</a><br/>
						- <a href="/robot/robot_control_usb_IMU.ino">robot_control_usb_IMU.ino</a><br/>
						- <a href="/robot/stereo_server.zip">stereo_server.zip</a>
						<br/>
						<br/>
						
						Pour utiliser ce code, Il faudra associer au projet non seulement les librairies OpenCV, mais également la librairie JSSC.jar se trouvant dans le dossier /usr/share/java/ (installer le package si la librairie n'y est pas) pour la communication avec l'Arduino du robot, et les librairies <a href="https://github.com/TooTallNate/Java-WebSocket/releases">Java-WebSocket.jar</a>, <a href="https://jar-download.com/artifacts/org.slf4j/slf4j-api">slf4j-api.jar</a> et <a href="https://jar-download.com/artifacts/org.slf4j/slf4j-simple">slf4j-simple.jar</a> pour le serveur. Dans la classe Main, il faudra spécifier, si nécessaire, le port utilisé par l'Arduino (par défaut "/dev/ttyACM0") et l'emplacement de la page HTML (par défaut "./"). Il est aussi possible d'activer/désactiver la fenêtre affichant l'image de la caméra et le contexte.<br/>
					</p>
					
					<figure style="text-align:center">
						<img src="/robot/dependancies_server.png" alt="librairies OpenCV et communication" width="300" />
					</figure>
					
					<p>
						Le nano ordinateur et le PC client doivent être connectés à un réseau Wifi ouvert. Une fois l'application Java lancée sur le robot, il suffit de se connecter, sur le PC client, avec un navigateur Web à l'adresse du robot, en utilisant le port 8080 (par exemple 192.168.1.100:8080). L'interface Web affiche le framerate, l'image de la caméra gauche et le contexte reconstruit à partir des informations issues du robot.
					</p>
					
					<figure style="text-align:center">
						<img src="/robot/interface1.png" alt="Interface Web" width="400" />
						<figcaption>Interface pour contôler le robot : en haut : affichage du nombre d'images/s du robot. En dessous, le contexte de points et la vue de la caméra gauche. En bas : les boutons de contrôle, permettant de piloter le robot et d'arrêter l'application. Trois boutons illustrent la possibilité de transmettre des messages et commandes au robot.</figcaption>
					</figure>
					
					<p>
						Le robot peut être contrôlé à l'aide des six boutons. Trois boutons ont été ajoutés pour illustrer l'envoi de message au serveur. Le contenu des messages peut être modifié dans le fichier index.html, dans la fonction JavaScript 'sendMsg', et leur traitement, dans la fonction onMessage de la classe DataWebSocket. Dans le cas où une IMU est connectée à l'Arduino, le robot corrige sa trajectoire lorsqu'il avance pour garder son cap.
					</p>
					
					
					<p style="text-align: center">
						<video width="500" controls >
							<source src="/robot/robot_web_control.mp4" type="video/mp4">
							Your browser does not support the video tag.
						</video> 
					</p>
					
					<p>
						Si l'application fonctionne correctement, il est possible d'exporter un JAR exécutable, qui pourra être lancé depuis une simple session SSH.
					</p>
					
				</section>
				
			</section>

			
			<section class="subsection">
				<section class="listsection">
				
					<p>
						<center style="text-align: center;font-size: xx-large;">Système de localisation pour une flottille de robots</center><br /><br />
					</p>

					<p>
						L'étude de nos modèles de navigation portent également sur la distribution du modèle sur plusieurs robots. Cette distribution doit permettre de répartir les besoins en ressources, et donc les ressources individuelles nécessaires pour chaque robot. Le principe implique que pendant qu'un robot guide le groupe, les autres peuvent être affectés à d'autres tâches, tout en suivant le robot-guide. Nous avons ainsi développé un système de suivi très simple mais efficace basé sur un code-barre vertical inscrit sur un tube en papier placé au sommet de chaque robot. Ce code-barre permet d'inscrire un code sur 4 bits et fourni une approximation de l'orientation (Voir figure ci-dessous).
					</p>
					<br/>
					
					<figure style="text-align:center">
						<img src="/robot/robot_barcode.jpg" alt="robot with barcode" width="300" />
						<figcaption>Le robot équipé de son code-barre vertical. Les deux lignes du haut et la ligne du bas constituent des marqueurs pour reconnaitre le code-barre. Quatre lignes peuvent ensuite figurer sur le code, fournissant un code à 4 bits (ici, le code 1001=9). La ligne de hauteur variable permet une approximation de l'orientation du robot, en comparant la hauteur de la ligne observée et la hauteur du code-barre.</figcaption>
					</figure>
			
				</section>

				<section class="listsection">
				
					<p>
						Un système de localisation visuel :
					</p>
				
					<p>
						Ce système de localisation permet aux robots de se localiser mutuellement, mais peut également servir de balise pour des projets liés à la navigation. Il repose sur l'utilisation de codes-barres verticaux inscrits sur des tubes de papiers permettant d'être visibles depuis n'importe quelle direction, contrairement aux marqueurs AR (ou ARtags). Cependant, il est nécessaire, pour mesurer les distances, que le code-barre soit à la même hauteur que la caméra.
					</p>
				
					<p>
						Ces codes-barres comportent un en-tête et un pied-de-page permettant de les reconnaitre, mais également d'en estimer la distance à partir de leur taille apparente. Le contenu comprend un code binaire sur 4 bits, permettant d'identifier le porteur de ce code. Une bande de hauteur variable permet également d'estimer l'orientation du code-barre, la hauteur de la partie visible étant dépendante du point de vue.
					</p>
				
					<figure style="text-align:center">
						<img src="/robot/barcode.png" alt="code barre" width="300" />
						<figcaption>Le code-barre est constitué de lignes horizontales. Les deux premières correspondent à l'en-tête, et la dernière, au pied-de-page, permettant la détection du code. Les quatre lignes sous l'en-tête peuvent être blanches ou noires, formant un code sur 4 bits. La ligne suivante a une hauteur variable, permettant de déterminer l'orientation du tube.</figcaption>
					</figure>
				
					<p>
						L'algorithme scanne chaque colonne de l'image, de haut en bas, et recherche les bordures horizontales. Lorsqu'un fort gradient négatif (passage du blanc au noir) est détecté, l'algorithme cherche ensuite un fort gradient positif (passage du noir au blanc), permettant la détection d'une bande noire.<br/> Lorsque deux bandes sont détectées, leur hauteurs et espacement sont comparés : la première bande doit être deux fois plus haute que la seconde, et l'espacement doit être équivalent à la hauteur de la seconde bande. Si ces rapports sont respectés, un en-tête est détecté.<br/>
						L'algorithme détermine, à partir de la hauteur de l'en-tête, une fenêtre de recherche pour le pied-de-page. Si une bande noire est détectée dans cette fenêtre, un code-barre est considéré comme présent.  
					</p>
				
					<p>
						L'algorithme détermine ensuite la position des quatre bandes du code binaire, et lit la couleur sur ces quatre positions. Le code binaire obtenu donne l'identifiant du code-barre.<br/>
						Puis, une fenêtre de recherche pour la bande variable est définie. La hauteur relative de cette bande par rapport à la heuteur du code est mesurée.<br/>
						Une fois l'image scannée, les codes identiques sont fusionnés pour obtenir la position horizontale et l'orientation du code-barre.
					</p>
					<br/>
				
					<p>
						Ce détecteur a été intégré dans l'application de la plateforme robotique, qui propose désormais trois modes de fonctionnement :<br/>
						- le mode mapping, qui génère un contexte de points d'intérêts par vision stéréoscopique,<br/>
						- le mode scanner, qui détecte et affiche le ou les codes-barres visibles,<br/>
						- le mode suivi, qui permet au robot de suivre un code-barre. 
					</p>
				
					<p>
						Ces différents modes peuvent être sélectionnés via trois boutons de l'interface web. Le protocole de communication s'enrichit de nouveaux mots-clés : côté client, 'changemode' permet de changer le mode de fonctionnement de l'application. Côté serveur, 'mode' permet d'afficher le mode actuel dans l'interface web. 
					</p>
				
					<p style="text-align: center">
						<video width="400" controls >
							<source src="/robot/robot_scanner.mp4" type="video/mp4">
							Your browser does not support the video tag.
						</video> 
						<br/>
						Le mode scanner affiche le ou les codes-barres visibles, en affichant l'identifiant, l'estimation de l'orientation, la position horizontale et la distance (donnée ici par la hauteur apparente). Le mode scanner désactive le système de vision stéréoscopique, permettant à l'application d'attendre entre 25 et 30 images/s.
					</p>
				
					<p>
						Le mode suivi permet au robot de suivre un code-barre particulier. L'identifiant du code-barre à suivre doit être spécifié dans les paramètres de la classe Main (paramètre 'CODE'). Le système de suivi cherche simplement à maintenir la position du code-barre à une certaine distance et orientation du robot.
					</p>
				
					<p>
						Mode suivi vue interface :
					</p>
				
					<p style="text-align: center">
						<video width="400" controls >
							<source src="/robot/robot_tracking1.mp4" type="video/mp4">
							Your browser does not support the video tag.
						</video> 
					</p>
				
					<p>
						Mode suivi vue observateur :
					</p>
				
					<p style="text-align: center">
						<video width="300" controls >
							<source src="/robot/robot_tracking2.mp4" type="video/mp4">
							Your browser does not support the video tag.
						</video> 
					</p>

					<p>
						Code source :<br/>
						- <a href="/robot/robot_control_usb.ino">robot_control_usb.ino</a><br/>
						- <a href="/robot/robot_control_usb_IMU.ino">robot_control_usb_IMU.ino</a><br/>
						- <a href="/robot/stereo_server_scanner.zip">stereo_server_scanner.zip</a><br/>
						- <a href="/robot/barcode.svg">barcode.svg</a>
						<br/>
						<br/>
					</p>
				
					<p>
						L'utilisation du code est identique à la version serveur : le projet doit être associé aux librairies OpenCV, JSSC.jar, <a href="https://github.com/TooTallNate/Java-WebSocket/releases">Java-WebSocket.jar</a>, <a href="https://jar-download.com/artifacts/org.slf4j/slf4j-api">slf4j-api.jar</a> et <a href="https://jar-download.com/artifacts/org.slf4j/slf4j-simple">slf4j-simple.jar</a>. Il faut ensuite spécifier dans la classe Main le port utilisé par l'Arduino et l'emplacement de la page HTML. L'application peut être exportée en exécutable JAR pour une utilisation depuis une connexion SSH.
					</p>
				
				</section>


				<section class="listsection">
				
					<p>
						Un système de communication entre robots :
					</p>
				
					<p>
						Pour permettre aux différents robots de la flotte de communiquer entre eux, nous avons ajouté un système de communication. Ce système repose sur le serveur déjà développé, et utilise les requêtes de type POST pour transmettre des messages.
					</p>
				
					<p>
						Les robots sont identifiés par un numéro d'identification défini comme le quatrième nombre de son adresse IP sur le réseau. Ainsi, un robot avec une adresse IP de 192.168.1.120 aura l'identifiant 120. Le protocole de communication retenu est le suivant : une communication est constituée du numéro de l'expéditeur et du message à envoyer sous forme d'une chaine de caractère, séparés par un point-virgule. Ce message est constitué soit d'un mot-clé seul, soit d'un mot-clé suivi de paramètres. Dans ce second cas, le mot-clé et ses paramètres sont séparés par un point-virgule, et les paramètres sont séparés entre eux par des virgules. L'exemple suivant montre une syntaxe valide, avec 120 l'adresse de l'expéditeur, "control" le mot-clé et "wait" et "5000" des paramètres :
					</p>
				
					<div  style="text-align: center">
						<code>
							"120;control;wait,5000"
						</code>
					</div>
				
					<p>
						La classe Serveur est modifiée pour traiter les requêtes de type POST : un message reçu est décomposé en identifiant, mot-clé et liste de paramètres. Le serveur stocke les informations liées au dernier message reçu pour un traitement ultérieur (le message peut ensuite être effacé avec la procédure <code>clear()</code>). Il est également possible de traiter directement le message dans la procédure <code>PostHandler</code> de la classe Serveur.
					</p>
				
					<p>
						Pour l'envoi de message, une nouvelle classe a été ajouté : la classe Talky. Celle-ci définit l'identifiant du robot à partir de son adresse IP et fournit une procédure <code>sendMsg</code> permettant d'envoyer un message à un autre robot. La procédure prend en argument l'identifiant du destinataire et le message (la procédure ajoute automatiquement l'identifiant expéditeur au message avant l'envoi).
					</p>
				
					<p>
						L'interface Web se voit ajouter un champ et un bouton illustrant l'envoi d'un message à un robot dont l'identifiant est spécifié. Ce message s'affichera dans le terminal du robot destinataire. Notons l'ajout du mot-clé 'message' dans l'interface Web pour demander au serveur d'envoyer un message via la procédure <code>sendMsg</code>.
					</p>
				
					<figure style="text-align:center">
						<img src="/robot/interface3.png" alt="Interface Web avec communication entre robots" width="400" />
						<figcaption>Interface améliorée : le champ texte permet d'indiquer l'identifiant d'un robot de la flotte. En cliquant sur le bouton associé, un message est envoyé à ce robot, qui s'affichera dans son terminal.</figcaption>
					</figure>
				
					<p>
						Code source :<br/>
						- <a href="/robot/robot_control_usb.ino">robot_control_usb.ino</a><br/>
						- <a href="/robot/robot_control_usb_IMU.ino">robot_control_usb_IMU.ino</a><br/>
						- <a href="/robot/stereo_server_scanner_talky.zip">stereo_server_scanner_talky.zip</a>
					</p>
				
					<p>
						L'utilisation du code est identique à la version précédente, et nécessite l'association des mêmes librairies et la spécification des mêmes paramètres.
					</p>
				
					<p>
						Ce système de communication a été utilisé pour étudier les possibilités de cartographie et de guidage sur plusieurs robots. Ici, un robot est piloté à distance et cartographie l'environnement. Le second robot suit le premier, puis, à intervalles réguliers, échangent leurs positions. Le système de communication permet aux robots de se synchroniser pendant l'échange. Chaque robot n'enregistre qu'une partie de la carte. Notre <a href="https://gaysimon.github.io/projects/navig_swarm1_en.html">modèle de navigation bio-inspiré</a> autorise cette distribution, mais aussi une exploitation d'un tel modèle distribué.
					</p>

					<p style="text-align: center">
 						<video width="300" controls >
  							<source src="/robot/multi_robots.mp4" type="video/mp4">
							Your browser does not support the video tag.
						</video> 
					</p>
				
				</section>
			</section>
		</div>

		
			<footer>
		<p>
			Derniers ajouts par section
		</p>

		<div class="footsection">
			<p>
				&nbsp;ROBOTS :<br />
				&nbsp;&nbsp;<a href="/robot/john2.html">Johnny 2.0 </a> <br />
				&nbsp;&nbsp;<a href="/robot/john3.html">Johnny 3 </a> <br />
				&nbsp;&nbsp;<a href="/robot/eirl.html">ErnestIRL </a> <br />
				&nbsp;&nbsp;<a href="/robot/ecce.html">EcceRobot </a> <br />
				&nbsp;&nbsp;<a href="/robot/epuck.html">ePuck </a> <br />
				&nbsp;&nbsp;<a href="/robot/robot_navigation.html">Plateforme omni-directionnelle </a> <br />
			</p>
		</div>

		<div class="footsection">
			<p>
				&nbsp;SOFTWARES :<br />
				&nbsp;&nbsp;<a href="/articles/sma.html">SMA </a> <br />
				&nbsp;&nbsp;<a href="/articles/vacu.html">vacuumSG </a> <br />
				&nbsp;&nbsp;<a href="/articles/littleai.html">Java LittleAI </a> <br />
				&nbsp;&nbsp;<a href="/articles/mvac.html">Microvacuum </a> <br />
				&nbsp;&nbsp;<a href="/articles/esimu.html">ErnestIRL simulator </a> <br />
				&nbsp;&nbsp;<a href="/articles/jsimu.html">Johnny 2 simulator </a> <br />
			</p>

		</div>

		<div class="footsection">
			<p>
				&nbsp;Le projet Ernest
			</p>
		</div>
	</footer>

	</body>
</html>
